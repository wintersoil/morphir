"use strict";
var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var fs_1 = __importDefault(require("fs"));
var os_1 = __importDefault(require("os"));
var path_1 = __importDefault(require("path"));
var process_1 = __importDefault(require("process"));
var tmp_1 = __importDefault(require("tmp"));
var chalk_1 = __importDefault(require("chalk"));
var cross_spawn_1 = __importDefault(require("cross-spawn"));
var express_1 = __importDefault(require("express"));
var serve_index_1 = __importDefault(require("serve-index"));
var express_ws_1 = __importDefault(require("express-ws"));
var ws_1 = __importDefault(require("ws"));
var glob_1 = __importDefault(require("glob"));
var sane_1 = __importDefault(require("sane"));
var opn_1 = __importDefault(require("opn"));
// For node < 8
require('util.promisify/shim')();
require("core-js/features/object/entries");
require("core-js/features/object/values");
var util_1 = __importDefault(require("util"));
var readFileAsync = util_1.default.promisify(fs_1.default.readFile);
var globAsync = util_1.default.promisify(glob_1.default);
var statAsync = util_1.default.promisify(fs_1.default.stat);
tmp_1.default.setGracefulCleanup();
express_1.default.static.mime.define({ "text/plain; charset=UTF-8": ["elm"] });
express_1.default.static.mime.define({ "text/plain; charset=UTF-8": ["md"] });
var npmPackage = require(path_1.default.join(__dirname, "../package.json"));
function info() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    console.log.apply(console, args);
}
function warning() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    console.log(chalk_1.default.yellow.apply(chalk_1.default, args));
}
function error() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    console.log(chalk_1.default.red.apply(chalk_1.default, args));
}
function fatal() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    error.apply(void 0, args);
    chalk_1.default.red("Exiting...");
    process_1.default.exit(1);
}
/*
 * Find and check Elm executable
 */
function getElm() {
    var elm = function (args, cwd) {
        if (cwd === void 0) { cwd = "."; }
        return cross_spawn_1.default.sync("npx", ["--no-install", "elm"].concat(args), { cwd: cwd });
    };
    var exec = elm(["--version"]);
    if (exec.error || exec.status !== 0 || exec.stderr.toString().length > 0) {
        elm = function (args, cwd) {
            if (cwd === void 0) { cwd = "."; }
            return cross_spawn_1.default.sync("elm", args, { cwd: cwd });
        };
        exec = elm(["--version"]);
    }
    if (exec.error) {
        fatal("cannot run 'elm --version' (" + exec.error + ")");
    }
    else if (exec.status !== 0) {
        error("cannot run 'elm --version':");
        process_1.default.stderr.write(exec.stderr);
        process_1.default.exit(exec.status ? exec.status : 1);
    }
    var version = exec.stdout.toString().trim();
    if (!version.startsWith("0.19")) {
        fatal("unsupported Elm version " + version);
    }
    return [elm, version];
}
function getElmCache(elmVersion) {
    var dir = os_1.default.platform() === "win32" ? "AppData/Roaming/elm" : ".elm";
    var home = process_1.default.env.ELM_HOME || path_1.default.join(os_1.default.homedir(), dir);
    var packages = elmVersion === "0.19.0" ? "package" : "packages";
    var cache = path_1.default.join(home, elmVersion, packages);
    return cache;
}
function getManifest(manifestPath) {
    return __awaiter(this, void 0, void 0, function () {
        var _this = this;
        return __generator(this, function (_a) {
            return [2 /*return*/, readFileAsync(manifestPath, "utf8")
                    .then(function (json) { return __awaiter(_this, void 0, void 0, function () {
                    var manifest, stat;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                manifest = JSON.parse(json);
                                return [4 /*yield*/, statAsync(manifestPath)];
                            case 1:
                                stat = _a.sent();
                                manifest["timestamp"] = Math.round(stat.mtime.getTime() / 1000);
                                manifest = completeApplication(manifestPath, manifest);
                                return [2 /*return*/, manifest];
                        }
                    });
                }); })
                    .catch(function (err) { return error(err); })];
        });
    });
}
function getManifestSync(manifestPath) {
    try {
        var json = fs_1.default.readFileSync(manifestPath, "utf8");
        var manifest = JSON.parse(json);
        var stat = fs_1.default.statSync(manifestPath);
        manifest["timestamp"] = Math.round(stat.mtime.getTime() / 1000);
        return completeApplication(manifestPath, manifest);
    }
    catch (err) {
        return null;
    }
}
function completeApplication(manifestPath, manifest) {
    if (manifest.type !== "application") {
        return manifest;
    }
    try {
        var elmAppPath = path_1.default.resolve(path_1.default.dirname(manifestPath), "elm-application.json");
        if (fs_1.default.existsSync(elmAppPath)) {
            var elmApp = JSON.parse(fs_1.default.readFileSync(elmAppPath).toString());
            Object.assign(manifest, elmApp);
        }
    }
    catch (err) {
        error(err);
    }
    if (!("name" in manifest)) {
        manifest.name = "my/application";
    }
    if (!("version" in manifest)) {
        manifest.version = "1.0.0";
    }
    if (!("summary" in manifest)) {
        manifest.summary = "Elm application";
    }
    if (!("license" in manifest)) {
        manifest.license = "Fair";
    }
    return manifest;
}
function fullname(manifest) {
    return manifest.name + "/" + manifest.version;
}
function searchPackages(pattern) {
    return __awaiter(this, void 0, void 0, function () {
        var paths, manifests, packages;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, globAsync(pattern + "/elm.json", { realpath: true })];
                case 1:
                    paths = _a.sent();
                    return [4 /*yield*/, Promise.all(paths.map(function (path) { return getManifest(path); }))];
                case 2:
                    manifests = _a.sent();
                    packages = manifests.reduce(function (acc, pkg) {
                        if (pkg.name && pkg.name in acc && pkg.version) {
                            acc[pkg.name].versions.push(pkg.version);
                            return acc;
                        }
                        else if (pkg.name && pkg.version) {
                            acc[pkg.name] = {
                                name: pkg.name,
                                summary: pkg.summary || "",
                                license: pkg.license || "Fair",
                                versions: [pkg.version]
                            };
                            return acc;
                        }
                        else {
                            warning("invalid elm.json", pkg);
                            return acc;
                        }
                    }, {});
                    return [2 /*return*/, packages];
            }
        });
    });
}
function packageReleases(pattern) {
    return __awaiter(this, void 0, void 0, function () {
        var paths, manifests, releases;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, globAsync(pattern + "/elm.json", {
                        realpath: true
                    })];
                case 1:
                    paths = _a.sent();
                    return [4 /*yield*/, Promise.all(paths.map(function (path) { return getManifest(path); }))];
                case 2:
                    manifests = _a.sent();
                    releases = manifests.reduce(function (releases, pkg) {
                        if (pkg.version && pkg.timestamp) {
                            releases[pkg.version] = pkg.timestamp;
                            return releases;
                        }
                        else {
                            return releases;
                        }
                    }, {});
                    return [2 /*return*/, releases];
            }
        });
    });
}
function merge(objects) {
    return objects.reduce(function (acc, obj) { return Object.assign(acc, obj); });
}
function buildDocs(manifest, dir, elm) {
    try {
        if (manifest.type == "package") {
            return buildPackageDocs(dir, elm);
        }
        else if (manifest.type == "application") {
            return buildApplicationDocs(manifest, dir, elm);
        }
    }
    catch (err) {
        error(err);
    }
    return {};
}
// Return a docs.json or a json error report
function buildPackageDocs(dir, elm) {
    var tmpFile = tmp_1.default.fileSync({ prefix: "elm-docs-", postfix: ".json" });
    var buildDir = path_1.default.resolve(dir);
    info("  |> building " + buildDir + " documentation");
    var build = elm(["make", "--docs=" + tmpFile.name, "--report=json"], buildDir);
    if (build.error) {
        error("cannot build documentation (" + build.error + ")");
    }
    var docs;
    try {
        docs = JSON.parse(fs_1.default.readFileSync(tmpFile.name).toString());
    }
    catch (err) {
        try {
            // Return Errors JSON report
            docs = JSON.parse(build.stderr.toString());
        }
        catch (err) {
            docs = {};
        }
    }
    tmpFile.removeCallback();
    return docs;
}
function buildApplicationDocs(manifest, dir, elm) {
    info("  |> building " + path_1.default.resolve(dir) + " documentation");
    // Build package from application manifest
    var elmStuff = path_1.default.resolve(dir, "elm-stuff");
    if (!fs_1.default.existsSync(elmStuff)) {
        fs_1.default.mkdirSync(elmStuff);
    }
    var tmpDir = tmp_1.default.dirSync({
        dir: elmStuff,
        prefix: "elm-application-",
        unsafeCleanup: true
    });
    var tmpDirSrc = path_1.default.resolve(tmpDir.name, "src");
    fs_1.default.mkdirSync(tmpDirSrc);
    // Build package manifest
    var pkg = {
        type: "package",
        name: manifest.name,
        summary: manifest.summary,
        license: manifest.license,
        version: manifest.version,
        "exposed-modules": manifest["exposed-modules"],
        "elm-version": versionToConstraint(manifest["elm-version"]),
        dependencies: {},
        "test-dependencies": {},
        timestamp: manifest.timestamp
    };
    // Add dependencies constraints
    if (manifest.dependencies.direct) {
        for (var _i = 0, _a = Object.entries(manifest.dependencies.direct); _i < _a.length; _i++) {
            var _b = _a[_i], name_1 = _b[0], version = _b[1];
            pkg.dependencies[name_1] = versionToConstraint(version);
        }
    }
    // Add source directories exposed-modules
    var exposedModules = getExposedModules(pkg["exposed-modules"]);
    if (manifest["source-directories"]) {
        manifest["source-directories"].forEach(function (src) {
            var srcDir = path_1.default.resolve(src);
            importModules(srcDir, tmpDirSrc);
            var elmJsonPath = path_1.default.resolve(src, "../elm.json");
            if (fs_1.default.existsSync(elmJsonPath)) {
                try {
                    var srcManifest = getManifestSync(elmJsonPath);
                    if (srcManifest && srcManifest.type === "package") {
                        var srcModules = getExposedModules(srcManifest["exposed-modules"]);
                        exposedModules = exposedModules.concat(srcModules);
                    }
                }
                catch (err) {
                    error(err);
                }
            }
        });
    }
    pkg["exposed-modules"] = exposedModules;
    // Write elm.json and generate package documentation
    var elmJson = JSON.stringify(pkg);
    fs_1.default.writeFileSync(tmpDir.name + "/elm.json", elmJson, "utf8");
    var docs = buildPackageDocs(tmpDir.name, elm);
    // remove temporary directory
    tmpDir.removeCallback();
    return docs;
}
function getExposedModules(manifestExposedModules) {
    var exposedModules = [];
    if (manifestExposedModules) {
        if (Array.isArray(manifestExposedModules)) {
            exposedModules = manifestExposedModules;
        }
        else if (typeof manifestExposedModules === "object") {
            Object.values(manifestExposedModules).forEach(function (modules) {
                exposedModules = exposedModules.concat(modules);
            });
        }
    }
    return exposedModules;
}
function importModules(srcDir, dstDir) {
    glob_1.default.sync("**/*.elm", { cwd: srcDir }).forEach(function (elm) {
        try {
            var dir = path_1.default.resolve(dstDir, path_1.default.dirname(elm));
            mkdirSyncRecursive(path_1.default.resolve(dstDir, dir));
            var srcModulePath = path_1.default.resolve(srcDir, elm);
            var dstModulePath = path_1.default.resolve(dstDir, elm);
            var module_1 = fs_1.default.readFileSync(srcModulePath).toString();
            if (module_1.match(/^port +module /) !== null) {
                // Stub ports by subscriptions and commands that do nothing
                info("  |> stubbing " + elm + " ports");
                module_1 = module_1.replace(/^port +([^ :]+)([^\n]+)$/mg, function (match, name, decl, off, str) {
                    if (name === "module") {
                        return ["module", decl].join(" ");
                    }
                    else if (decl.includes("Sub")) {
                        info("  |> stubbing incoming port", name);
                        return name + " " + decl + "\n" + name + " = always Sub.none\n";
                    }
                    else if (decl.includes("Cmd")) {
                        info("  |> stubbing outgoing port", name);
                        return name + " " + decl + "\n" + name + " = always Cmd.none\n";
                    }
                    else {
                        warning("unmatched", match);
                    }
                    return match;
                });
                fs_1.default.writeFileSync(dstModulePath, module_1);
            }
            else {
                linkModule(srcModulePath, dstModulePath);
            }
        }
        catch (err) {
            error(err);
        }
    });
}
function mkdirSyncRecursive(dir) {
    var absoluteDir = path_1.default.resolve(dir);
    var sep = path_1.default.sep;
    absoluteDir.split(sep).reduce(function (parent, child) {
        var d = path_1.default.resolve(parent, child);
        try {
            if (!fs_1.default.existsSync(d)) {
                fs_1.default.mkdirSync(d);
            }
        }
        catch (err) {
            error(err);
        }
        return d;
    }, "/");
}
function linkModule(linked, link) {
    try {
        if (!fs_1.default.existsSync(link)) {
            if (os_1.default.platform() === "win32") {
                // Windows requires to be admin to create symlinks
                fs_1.default.copyFileSync(linked, link);
            }
            else {
                fs_1.default.symlinkSync(linked, link);
            }
        }
    }
    catch (err) {
        error(err);
    }
}
function versionToConstraint(version) {
    var _a = version.split(".", 3), major = _a[0], minor = _a[1], patch = _a[2];
    var nextPatch = parseInt(patch) + 1;
    return major + "." + minor + "." + patch + " <= v < " + major + "." + minor + "." + nextPatch;
}
var DocServer = /** @class */ (function () {
    function DocServer(dir) {
        var _a;
        if (dir === void 0) { dir = "."; }
        this.dir = fs_1.default.lstatSync(dir).isFile() ? path_1.default.dirname(dir) : dir;
        try {
            process_1.default.chdir(dir);
        }
        catch (err) {
            error(err);
        }
        _a = getElm(), this.elm = _a[0], this.elmVersion = _a[1];
        this.elmCache = getElmCache(this.elmVersion);
        var app = express_1.default();
        this.ws = express_ws_1.default(app);
        this.app = this.ws.app;
        this.wss = this.ws.getWss();
        this.manifest = getManifestSync("elm.json");
        this.timeout = null;
        info(chalk_1.default(templateObject_1 || (templateObject_1 = __makeTemplateObject(["{bold elm-doc-preview ", "} using elm ", ""], ["{bold elm-doc-preview ", "} using elm ",
            ""])), npmPackage.version, this.elmVersion));
        if (this.manifest && this.manifest.name && this.manifest.version) {
            info(chalk_1.default(templateObject_2 || (templateObject_2 = __makeTemplateObject(["Previewing {magenta ", " ", "}"], ["Previewing {magenta ", " ", "}"])), this.manifest.name, this.manifest.version), "from " + path_1.default.resolve(dir));
        }
        else {
            info("No package or application found in " + this.dir + ",", "running documentation server only");
        }
        this.setupWebServer();
        if (this.manifest) {
            this.setupFilesWatcher();
        }
    }
    DocServer.prototype.setupWebServer = function () {
        var _this = this;
        this.app.use("/", express_1.default.static(path_1.default.join(__dirname, "../static"), {
            index: "../static/index.html"
        }));
        // websockets
        this.app.ws("/", function (socket, req) {
            info("  |> " + req.connection.remoteAddress + " connected");
            socket.on("close", function () {
                info("  |> client disconnected");
            });
        });
        // preview
        this.app.get("/preview", function (req, res) {
            if (_this.manifest) {
                res.json(_this.manifest);
            }
        });
        // search.json
        this.app.get("/search.json", function (req, res) {
            Promise.all([_this.elmCache + "/*/*/*", "."]
                .map(function (pattern) { return searchPackages(pattern); }))
                .then(function (packagesArray) {
                // add/overwrite cache with project
                res.json(Object.values(merge(packagesArray)));
            })
                .catch(function (err) { return error(err); });
        });
        // releases.json
        this.app.get("/packages/:author/:project/releases.json", function (req, res) {
            var p = req.params;
            var name = p.author + "/" + p.project;
            var dirs = [_this.elmCache + "/" + name + "/*"];
            if (_this.manifest && _this.manifest.name === name) {
                dirs.push(".");
            }
            Promise.all(dirs.map(function (dir) { return packageReleases(dir); }))
                .then(function (releasesArray) {
                // add/overwrite cache with project
                res.json(merge(releasesArray));
            })
                .catch(function (err) { return error(err); });
        });
        // docs.json
        this.app.get("/packages/:author/:project/:version/docs.json", function (req, res) {
            var p = req.params;
            var name = p.author + "/" + p.project + "/" + p.version;
            if (_this.manifest && fullname(_this.manifest) === name) {
                res.json(buildDocs(_this.manifest, ".", _this.elm));
            }
            else {
                res.sendFile(path_1.default.resolve(_this.elmCache, name, "docs.json"));
            }
        });
        // Serve README.md files
        this.app.get("/packages/:author/:project/:version/README.md", function (req, res) {
            var p = req.params;
            var name = [p.author, p.project, p.version].join("/");
            if (_this.manifest && fullname(_this.manifest) === name) {
                res.sendFile(path_1.default.resolve(".", "README.md"));
            }
            else {
                res.sendFile(path_1.default.resolve(_this.elmCache, name, "README.md"));
            }
        });
        // Serve elm.json files
        this.app.get("/packages/:author/:project/:version/elm.json", function (req, res) {
            var p = req.params;
            var name = p.author + "/" + p.project + "/" + p.version;
            if (_this.manifest && fullname(_this.manifest) === name) {
                var manifest = getManifestSync("elm.json");
                res.json(manifest);
            }
            else {
                res.sendFile(path_1.default.resolve(_this.elmCache, name, "elm.json"));
            }
        });
        var setHeaders = function (res, path, stat) {
            if (path.endsWith("/LICENSE")) {
                res.setHeader("Content-Type", "text/plain; charset=UTF-8");
            }
        };
        // Serve project source
        if (this.manifest) {
            this.app.use("/source/" + fullname(this.manifest), express_1.default.static(".", { setHeaders: setHeaders }), serve_index_1.default(".", { icons: true }));
        }
        // Serve cached packages source
        this.app.use("/source", express_1.default.static(this.elmCache, { setHeaders: setHeaders }), serve_index_1.default(this.elmCache, { icons: true }));
        // default route
        this.app.get("*", function (req, res) {
            res.sendFile(path_1.default.join(__dirname, "../static/index.html"));
        });
    };
    DocServer.prototype.setupFilesWatcher = function () {
        var _this = this;
        var glob = ["elm.json", "elm-application.json", "README.md"];
        if (this.manifest && this.manifest["source-directories"]) {
            this.manifest["source-directories"].forEach(function (src) {
                glob.push(src + "/**/*.elm");
                glob.push(path_1.default.normalize(src + "/../elm.json"));
            });
        }
        else if (this.manifest) {
            glob.push("src/**/*.elm");
        }
        var watcher = sane_1.default(this.dir, {
            glob: glob,
            ignored: ["**/node_modules", "**/elm-stuff"]
        });
        watcher.on("ready", function () {
            if (_this.manifest && _this.manifest.type === "package") {
                info("  |> watching package");
            }
            else if (_this.manifest && _this.manifest.type === "application") {
                info("  |> watching application");
            }
        });
        watcher.on("change", function (filepath) {
            _this.onChange(filepath);
        });
        watcher.on("add", function (filepath) {
            _this.onChange(filepath);
        });
        watcher.on("delete", function (filepath) {
            _this.onChange(filepath);
        });
    };
    DocServer.prototype.onChange = function (filepath) {
        var _this = this;
        // Update docs with debounce: try to batch consecutive updates
        // (for example the way vim saves files would lead to 3 rebuilds else)
        if (this.timeout) {
            clearTimeout(this.timeout);
        }
        this.timeout = setTimeout(function () {
            _this.timeout = null;
            info("  |>", "detected", filepath, "modification");
            if (filepath.endsWith("README.md")) {
                _this.sendReadme();
            }
            else if (filepath.endsWith(".json")) {
                _this.manifest = getManifestSync("elm.json");
                _this.sendManifest();
                _this.sendDocs();
            }
            else if (filepath.endsWith(".elm")) {
                _this.sendDocs();
            }
        }, 100);
    };
    DocServer.prototype.sendReadme = function () {
        var readme = path_1.default.join(this.dir, "README.md");
        if (this.manifest && this.manifest.name && this.manifest.name.includes("/")) {
            var _a = this.manifest.name.split("/", 2), author = _a[0], project = _a[1];
            try {
                info("  |>", "sending README");
                this.broadcast({
                    type: "readme",
                    data: {
                        author: author,
                        project: project,
                        version: this.manifest.version,
                        readme: fs_1.default.readFileSync(readme).toString()
                    }
                });
            }
            catch (err) {
                error(err);
            }
        }
    };
    DocServer.prototype.sendManifest = function () {
        if (this.manifest) {
            if (this.manifest && this.manifest.name && this.manifest.name.includes("/")) {
                var _a = this.manifest.name.split("/", 2), author = _a[0], project = _a[1];
                info("  |>", "sending Manifest");
                this.broadcast({
                    type: "manifest",
                    data: {
                        author: author,
                        project: project,
                        version: this.manifest.version,
                        docs: this.manifest
                    }
                });
            }
        }
    };
    DocServer.prototype.sendDocs = function () {
        if (this.manifest) {
            if (this.manifest && this.manifest.name && this.manifest.name.includes("/")) {
                var docs = buildDocs(this.manifest, this.dir, this.elm);
                var _a = this.manifest.name.split("/", 2), author = _a[0], project = _a[1];
                info("  |>", "sending Docs");
                this.broadcast({
                    type: "docs",
                    data: {
                        author: author,
                        project: project,
                        version: this.manifest.version,
                        time: this.manifest.timestamp,
                        docs: docs
                    }
                });
            }
        }
    };
    DocServer.prototype.listen = function (port, browser) {
        var _this = this;
        if (port === void 0) { port = 8000; }
        if (browser === void 0) { browser = true; }
        return this.app.listen(port, function () {
            if (browser && _this.manifest && _this.manifest.name && _this.manifest.version) {
                opn_1.default("http://localhost:" + port + "/packages/" + _this.manifest.name + "/" + _this.manifest.version + "/");
            }
            else if (browser) {
                opn_1.default("http://localhost:" + port);
            }
            info(chalk_1.default(templateObject_3 || (templateObject_3 = __makeTemplateObject(["{blue Browse} {bold {green <http://localhost:", ">}}"], ["{blue Browse} {bold {green <http://localhost:", ">}}"])), port.toString()), chalk_1.default(templateObject_4 || (templateObject_4 = __makeTemplateObject(["{blue to see your documentation}"], ["{blue to see your documentation}"]))));
        });
    };
    DocServer.prototype.broadcast = function (obj) {
        this.wss.clients.forEach(function (client) {
            if (client.readyState === ws_1.default.OPEN) {
                client.send(JSON.stringify(obj));
            }
        });
    };
    return DocServer;
}());
module.exports = DocServer;
var templateObject_1, templateObject_2, templateObject_3, templateObject_4;
//# sourceMappingURL=elm-doc-server.js.map